<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Disk Diagnostic: Disc Drive Diagnostic</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Disk Diagnostic
   </div>
   <div id="projectbrief">Scriptable diagnostic for disk drives</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Disc Drive Diagnostic </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Operates on a Windows physical drive. Directly accesses sectors on the drive, placing the sector contents in a buffer. Accesses the drive at the lowest level, a Windows physical drive.</p>
<p>The diagnostic maintains two buffers, one for reads and one for writes, which hold a large number of sectors (currently 256, but configurable). The idea is that you can set up patterns in the write buffer to be written out to disc, then read sectors into the read buffer for check, comparision or examination.</p>
<p>The diagnostic is CLI oriented, and is "minimally scriptable". This means it supports multiple commands on a line, loops, variables, and other abilities. The emphasis was on simple commands, oriented entirely to disc operations, and allowing as much to occur on a single command line as possible.</p>
<p>Commands available:</p>
<p>?, help - Print command help.</p>
<p>r, read [lba][num] - Read sector(s) at LBA, default read 0 1.</p>
<p>w, write [lba][num] - Read sector(s) at LBA, default read 0 1.</p>
<p>dw, dumpwrite [num] - Dump sector(s) from write buffer, default 1.</p>
<p>dr, dumpread [num] - Dump sector(s) from read buffer, default 1.</p>
<p>pt, pattn [pat [val [cnt]]] - Set write buffer to pattern, default is count.</p>
<p>c, comp [pat [val [cnt]]] - Compare read buffer to pattern, default is count.</p>
<p>cm, compmode mode - Set miscompare handling mode.</p>
<p>drive [num] - Set current physical drive, default is print current.</p>
<p>listdrives, ld - List available physical drives.</p>
<p>unprot - Unprotect current drive.</p>
<p>echo [text] - Echo the parameter area with next line.</p>
<p>echon [text] - Echo the parameter area without next line.</p>
<p>p, print ["fmt"] val... - Print a calulated value with next line.</p>
<p>pn, printn ["fmt"] val... - Print a calulated value with NO next line.</p>
<p>l, loop [num] - Loop from line start num times, default is forever.</p>
<p>lq, loopq [num] - Loop quiet from line start num times, def. is for.</p>
<p>u [num] - Loop until condition is true.</p>
<p>while cond - Start while/wend loop. Exec loop if cond is true.</p>
<p>wend - Terminate while/wend loop.</p>
<p>repeat - Start repeat/until loop.</p>
<p>until cond - End repeat/until loop. Repeat if cond is false.</p>
<p>for var start end [step] - Run for loop, start to end in var.</p>
<p>fend - End for loop.</p>
<p>select val - Select value, match successive cases for val.</p>
<p>case val... - Start new select case.</p>
<p>default - Start select case matching any value.</p>
<p>send - Terminate select statement.</p>
<p>if cond - Continue if condition met, otherwise next line.</p>
<p>go label - Go to program label.</p>
<p>end - Terminate procedure.</p>
<p>s, set var val - Set/reset user variable.</p>
<p>local var - Mark variable as local.</p>
<p>srand - Reset random number sequence.</p>
<p>list - List stored program.</p>
<p>clear - Clear stored program.</p>
<p>save filename - Save stored program to file.</p>
<p>load filename - Load stored program from file.</p>
<p>delt num - Delete line in program with line number.</p>
<p>exit - Exit diagnostic.</p>
<p>exitonerror - Exit the diagnostic on error.</p>
<p>i, input var - Input value from user.</p>
<p>[option] Means an optional parameter.</p>
<p>Multiple commands can appear on a line as a; b; c...</p>
<p>Patterns are:</p>
<p>cnt - Byte incrementing count.</p>
<p>dwcnt - 32 bit incrementing count.</p>
<p>val - Numeric 32 bit value, big endian.</p>
<p>rand - Random byte value.</p>
<p>lba - Only the first 32 bits get LBA, rest is $ff. LBA starts at [val], and increments across buffer. Note that this only writes the first dword of each sector, use another pattern to fill the background.</p>
<p>buffs - Compare the read and write buffers to each other. This allows complex patterns to be built up in the write buffer.</p>
<p>All write operations are from the write buffer.</p>
<p>All read operations are from the read buffer.</p>
<p>All drives start write locked, and are relocked when the drive is changed.</p>
<p>User variables start with a-z and continue with a-z and 0-9 like Myvar1. They are created or recreated by set, and can be set any number of times. A variable can be used anywhere a val can.</p>
<p>There are several predefined variables:</p>
<p>drvsiz - Gives the size of the current physical drive.</p>
<p>rand - Gives a random number.</p>
<p>lbarnd - Gives a random LBA for the current drive, ie., a random number that fits into 0..drvsiz-1.</p>
<p>secsiz - Size of sector in bytes (always 512).</p>
<p>bufsiz - Size of read and write buffers in sectors.</p>
<p>The compare modes are:</p>
<p>all - Show all mismatches.</p>
<p>one - Show only the first mismatch.</p>
<p>fail - Fail (abort) after the first mismatch (normal is continue).</p>
<p>All numeric parameters can be expressions, using C style expression operators +a,-a,(a),a*b,a/b,ab,a+b,a-b,a&lt;b,a&gt;b,a=b, a!=b,a&lt;=b and a&gt;b. Note that expressions cannot contain spaces, ie., a numeric parameter cannot have spaces within it.</p>
<p>Format strings used with print must start and end with double quotes. They can contain standard C style format specifiers like %[w[.p]f, where the format character is d, x, or o, for decimal, hexadecimal or octal. The sign and length cannot be specified, since debug values are always signed long long values. Anything else in the format string is printed. There are no character escapes, use pn/printn and p/print to specify or leave out a newline after printout.</p>
<p>Note that leading zeros don't work in the field width. Use the precision instead, i.e., %4.4x not %04x.</p>
<p>Stored program lines are entered with a leading number as:</p>
<p>Diag&gt; 1 dothis(num): echon The number is: ; p num</p>
<p>The line is inserted BEFORE the line in the program.</p>
<p>Any line with a label (as "dothis:" above) can be called as a procedure by using it's label as a command as:</p>
<p>Diag&gt; dothis 42</p>
<p>Note parameters are optional.</p>
<p>Procedure execution stops with an "end" command, and execution resumes after the calling command.</p>
<p>All variables created in a procedure are temporary and removed at the end of the procedure. Variables are only created in a procedure if they don't exist outside of the procedure OR if "local" is used. Note that parameters are automatically local.</p>
<p>Note that hitting the end of the program buffer terminates the run ALWAYS.</p>
<p>The file "discdiag.ini", if present in the current directory, is automatically loaded when discdiag starts. If the file contains a procedure "init", that will be executed automatically on startup.</p>
<p>*** WARNING: This diagnostic CAN and WILL distroy your hard disc!</p>
<p>Typical operations:</p>
<p>diag&gt; s lba 0</p>
<p>diag&gt; p lba; pt lba lba; w lba bufsiz; s lba lba+buzsiz; l 4096</p>
<p>Writes the full drive with the "lba identify pattern", or the lba number as the first 32 bits (big endian) of each sector. The lba is printed each time through the loop. Note that "pt lba lba" means "pattern the write buffer with the lba pattern, and use lba numbers starting with the value in the variable lba". The first parameter of pt is the pattern name, the second is numeric/ expression. 4096 is 1 megasector divided by 256, the size of the buffer.</p>
<p>diag&gt; s lba 0</p>
<p>diag&gt; p lba; r lba bufsiz; c lba lba; s lba lba+bufsiz; l 4096</p>
<p>This verifies the lba pattern we just wrote.</p>
<p>Bugs/wants/issues:</p>
<ol type="1">
<li>The calls used, readfile and writefile, hide errors from the drive. I know it is possible to retrieve actual errors from the drive, iometer does it. It would be far better if discdiag registered these errors (this may be a windows only issue).</li>
</ol>
<p>Compilation:</p>
<p>Windows:</p>
<p>I struggled with trying to get a standalone image from Visual studio. It does not work unless you carry the entire Visual studio environment to the target, which is not real practical. Cygwin has similar problems. The best way I found is to get mingw and compile it:</p>
<ol type="1">
<li>Go to www.mingw.org and get the current mingw distribution. This will go to c: by default.</li>
<li>Execute "c:\mingw\gcc -o discdiag discdiag.c". This is also in the file cdiscdiag.bat.</li>
</ol>
<p>The result is .dll free and will run anywhere (yea).</p>
<p>Linux:</p>
<p>Compiles with the stock gcc compiler. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Dec 18 2013 10:05:58 for Disk Diagnostic by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
